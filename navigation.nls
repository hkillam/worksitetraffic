;;
;; NAVIGATION
;;
;; a collection of functions that determine how breadcrumbs 
;; are made and how workers find their way around.
;;
;;


;;
;; blaze-trail
;;
;; calls create-breadcrumbs 5 times, returns the shortest path
;;
to-report blaze-trail [src dst bold danger-harms]
    let besttrail (list 0 0 0 100000)
    let newtrail (list 0 0 0 1000)
    foreach [1 2 3 4 5] [
       set newtrail create-breadcrumbs src dst bold danger-harms  
       if length newtrail > 6 and item 3 newtrail < item 3 besttrail 
       [ set besttrail newtrail ]
    ]
    report besttrail
end

;;
;; create-breadcrumbs-from_buildinglist
;;
;; AFTER building list is built,
;; AFTER buildings are all drawn,
;; BEFORE workers are created
;;
to create-breadcrumbs-from_buildinglist
  
    foreach building-list [
      let buildnum  item 0 ?
      let dest item 7 ?
      let mud-slows 0
      if item 8 ? > 0 or item 9 ? > 0 
      [ set mud-slows 1 ]
      let danger-harms item 10 ?

      foreach dest [
        if not trail-exists buildnum ? 0 0 [
          
        ]
      ]


      ;; make sure there is a breadcrumb trail for every destination
      foreach dest [
        if not trail-exists buildnum ? 0 0 [
            let newtrail blaze-trail buildnum ? 0 0
            if length newtrail > 6 [
               set breadcrumb-trails lput newtrail breadcrumb-trails
            ]
        ]
        if not trail-exists buildnum ? mud-slows danger-harms [
            let newtrail blaze-trail buildnum ? mud-slows danger-harms
            if length newtrail > 6 [
              set breadcrumb-trails lput newtrail breadcrumb-trails
            ]
        ]
      ]
    ]  
end

;;
;; trail-exists
;;
;; do we have breadcrumbs for this trail?
;;
to-report trail-exists [src dst bold danger-harms]
  foreach breadcrumb-trails [
    if item 0 ? = src and item 1 ? = dst and item 2 ? = bold and item 3 ? = danger-harms
    [ report true ]
    if item 1 ? = src and item 0 ? = dst and item 2 ? = bold and item 3 ? = danger-harms
    [ report true ]
  ]  
  report false
end

;;
;; create-breadcrumbs
;;
;; returns an arrary of [src dst bold length [x,y] [x,y] [x,y]...]
;; call this function before workers are created, all will die at the end.
;;
to-report create-breadcrumbs [src dst bold danger-harms]
  let breadcrumbs (list src dst bold 0)
  let show-test-msgs false
  let stop-spinning 800
  
  create-temp-worker src dst bold danger-harms
  
  ask workers
  [
    
       ;; march until we find the building or we have gone in 1000 circles
       while [[building-number] of patch-ahead 1 != dst and length breadcrumbs < stop-spinning] [
         let lastheading heading
         
         ;; decide where to go, and get there
         move-one-step
         
         ;; add our current position to the list of breadcrumbs.  we can skip this if there was no change in direction
        ;; if lastheading != heading [
             set breadcrumbs add-breadcrumb breadcrumbs
        ;; ]

       ]
       set breadcrumbs lput (list pxcor pycor) breadcrumbs  ;; add final point to the list

       ;; optimize the list (unless we hit 1000 points and gave up)
       if length breadcrumbs < stop-spinning [
         let index 4
         while [index + 2 < length breadcrumbs] [
           set breadcrumbs optimize-breadcrumbs breadcrumbs index  ;; start at 5th item, first four are not points
           set index index + 1
         ] 
       ]
       
       if length breadcrumbs > 4 and length breadcrumbs < stop-spinning [
         ;; measure the list
         let pathlength measure-breadcrumb-trail breadcrumbs
         set breadcrumbs replace-item 3 breadcrumbs pathlength
       ]       
       ;; done with this temp, kill him
       die
  ]  
  
  if length breadcrumbs > stop-spinning - 1 or length breadcrumbs < 6 [
     ;; show "scout is lost, send someone else"
     set breadcrumbs []
  ]
  
  report breadcrumbs
end   ;; create-breadcrumbs


;;
;; measure-breadcrumb-trail
;;
;; pass in a breadcrumb trail, return a total length
;; used in turtle context
;;
to-report measure-breadcrumb-trail [trail]
   let thelength 0
   hatch 1 [

      let pt1 item 4 trail
      setxy  item 0 pt1 item 1 pt1
      
      foreach trail [
        if is-list? ? [
          set thelength thelength + distancexy item 0 ? item 1 ?
          move-to patch item 0 ? item 1 ?
        ]
      ]
      die;
   ]
   
   report thelength
end

;;
;; move-one-step
;;
;; tell a worker to look around and decide where to move, and go there
;; uses the range of possible paths and chooses the best, or it hugs an edge.
;; 
;;
to move-one-step
  
     ;; first check for a nice clear path with a buffer, then try a clear skinny path
     let mypaths []
     if hugging-edges-steps < 1 [
       ;; get list of all possible paths
       set  mypaths possible-path-list self 2 false
       if length mypaths = 0 [ 
         set mypaths possible-path-list self 0 false
       ]  ;; if there aren't good paths with some buffer, try again with no buffer
     ]
     
     ;; if we dont have a path, start hugging the edge
     if length mypaths = 0 and hugging-edges-steps < 1
     [ set hugging-edges-steps 9 ] 
     
     
     ifelse hugging-edges-steps > 0[
       ;; there are no paths, hug the edges, turn towards the next step
       set hugging-edges-steps hugging-edges-steps - 1
       let ret turn-along-edge  
     ][
       ;; choose the best path, and turn towards the next step
       let myheading bestheading-path mypaths
       set heading myheading
     ]
     
     ;; double-check to see if it is a safe step, and move one.
     let nextpatchcolor [pcolor] of patch-ahead 1
     if ( member? nextpatchcolor  allowed-patches) 
     [ forward 1 ]
     
     
end

;;
;; optimize-breadcrumbs
;;
;; look at three points starting at index.  If there is a direct path 
;; from the first to third, remove the second.  And repeat.
;; returns the shortened breadcrumbs 
to-report optimize-breadcrumbs [breadcrumbs index]
  
  if index + 2 < length breadcrumbs [
    
    let pt1 item index breadcrumbs
    let pt2 item (index + 2) breadcrumbs
    
    if path-clear pt1 pt2 2 = true [
      ;; remove the point that is not needed, recurse deeper in.
      set breadcrumbs remove-item (index + 1) breadcrumbs
      set breadcrumbs optimize-breadcrumbs breadcrumbs index
    ]
    
  ]

  report breadcrumbs
end

;;
;; draw-breadcrumb-trail
;;
;; only used for diagnostic purposes.  does not affect how the workers move.
;; note that all workers are dead at the end of this, so call it before setting up workers.
;;

to draw-breadcrumb-trail [path]
without-interruption [  
  
  create-temp-worker 1 1 1 1
  
  if length path > 4 [
    
    let pt1 item 4 path
    ask workers [ 
      set color random (9) * 10 + 5
      setxy  item 0 pt1 item 1 pt1
      pen-down 
    ]
    
    foreach path [
      if is-list? ? [
        ask workers [ move-to patch item 0 ? item 1 ?  ]
      ]
    ]
  ]
  
  ask workers [ die ]
]
end  ;; draw-breadcrumb-trail

;;
;; path-clear
;;
;; create a temporary worker to walk from one point to the second, and see if there is anything in the way
;;
;; returns true/false
;; 
to-report path-clear [pt1 pt2 radius]
  let isclear true 
  let dude who
  let debug-mode false
  if who = -1 [set debug-mode true]
  hatch 1 [ 
    if debug-mode = true [show (word "hatched a who " who )]
    ;; move our guy to the first breadcrumb, and look at the next
    if debug-mode = true [
      show (word pt1 pt2 )
      setxy item 0 pt2 item 1 pt2 
;;      set size 0.1 
      set color red 
      ;;pen-down 
      show (word "src: " pt1 " dest: " pt2)
      show (word "allowed colors: " allowed-patches)
     ]  ;; show the line
    setxy  item 0 pt1 item 1 pt1
    if debug-mode = true [pen-up]
    face-nowrap patch item 0 pt2 item 1 pt2
    let dist distancexy  item 0 pt2 item 1 pt2
    if debug-mode = true [ show dist ]
    let step-counter 1                              ;; count steps along the path that is being examined
    
   
    ;; if (not is-allowed-patch patch-ahead step-counter 2 allowedpatches)
    while [step-counter < dist + 1 and isclear = true] [
      if debug-mode = true [
;;        show ( word patch-ahead step-counter " "  [pcolor] of patch-ahead step-counter) 
;;        show is-allowed-patch patch-ahead step-counter radius
        
      ]
      if  patch-ahead step-counter = patch item 0 pt2 item 1 pt2 [ die report isclear]
      set step-counter step-counter + 1
      
      if ( is-allowed-patch patch-ahead step-counter radius = false) [
        if debug-mode = true [
          show (word "problem " step-counter " steps ahead at patch " patch-ahead step-counter " colour " [pcolor] of patch-ahead step-counter)
          show (word "from patch " pt1 " to patch " pt2 " only using " allowed-patches)
        ]
        set isclear false
      ]
    ]
    
    ;; diagnostic 
    if isclear = true and debug-mode = true [
      ;;pen-down
      set color blue
      move-to patch item 0 pt2 item 1 pt2
    ]
    
    die
  ]

  report isclear
end

;;
;; create-temp-worker
;;
;; creates and initializes a temporary worker
;;
to create-temp-worker [src dst bold danger-harms]
  create-workers 1 
  ask workers [
      move-to one-of patches with [building-number = src]
      init-worker red red (list dst) src 1 1 1
      set shape "arrow"
      set size 3
      ifelse bold = 1 [
        set-worker-bold red danger-harms
      ][
        set-worker-avoider green
      ]
  ]
end

;;
;; bestheading-path
;;
;; receives a list of [heading distance] options
;; returns heading with the longest distance
;;
to-report bestheading-path [mypaths]
  
   let myheading  heading
   let step-count  0
   foreach mypaths [
     if  item 1 ? > step-count [
       set myheading  item 0 ?
       set step-count  item 1 ?
       if item 1 ? > 23 [ 
         set blue-sky-steps 20
       
       ]
     ]
   ]
   report myheading
end

;;
;; add-breadcrumb
;;
;; adds the current location of the current worker to the end of the breadcrumbs array
;; returns the breadcrumbs
;;
to-report add-breadcrumb [breadcrumbs]
   set breadcrumbs lput (list pxcor pycor) breadcrumbs
   report breadcrumbs
end


;;
;; show-planned-path
;;
;; helper function - sketch the path we plan to follow
;; visible lines do not affect how turtles move - the patch color under the path is not changed.
;;
to show-planned-path [steps]
       if steps > 0  [
         hatch 1 [
           set color blue
           set size 0.01
           ;; pen-down fd steps
          ;; wait 1
          ;; pen-erase bk steps
           die
         ]]
end


;;
;; select-breadcrumbs [ src dest bold ]
;;
;; Called when a worker picks a destination, or changes direction.
;; returns an array of (pathindex reversed point)
;; where point is the position in the array of points
;;
to-report select-breadcrumbs [src dest bold ]
   let ndx 0
  
   foreach breadcrumb-trails
   [ 
      if src = item 0 ? and dest = item 1 ? and bold = item 2 ? [ report ( list ndx false 4) ]
      if src = item 1 ? and dest = item 0 ? and bold = item 2 ? [ report ( list ndx true (length ? - 1)) ]
      set ndx ndx + 1
   ]
   report (list )
end


;;
;; follow-the-yellow-brick-road
;;
;; face the next breadcrumb, and don't step on each other.
;;
to follow-the-yellow-brick-road
  let debug-mode false
  if who = -1 [set debug-mode true]
  
  ;; are we still playing?
  if color = black [ stop ]


  ;; can we see the actual goal?
  if path-clear (list pxcor pycor) (list [pxcor] of goal [pycor] of goal) 0 = true
  [
    if debug-mode [
      show (word "it thinks the path is clear to the goal.  " item trail-id breadcrumb-trails )
    ]
    face-nowrap goal
    stop
  ]
  
  if breadcrumb-num < 4
  [
    ;; there are no crumbs if there is a direct path between buildings.  but we might be in a corner somewhere.
    if debug-mode [ show (word "no crumbs, and can't see goal, stuck in a weird corner " pxcor "," pycor " " goal)]
    stop
  ] 
  
;;  show (word "on patch " pxcor ", " pycor " using crumb " breadcrumb-num)
  
  ;; can we see the next crumb
  let next-crumb-num breadcrumb-num + 1
  if breadcrumb-reverse = true [set next-crumb-num breadcrumb-num - 1]
;;  show breadcrumb-reverse
  let crumb []
  if next-crumb-num < length item trail-id breadcrumb-trails [
     set crumb item next-crumb-num ( item trail-id breadcrumb-trails)
  ]
;;  show item trail-id breadcrumb-trails
;;  show breadcrumb-num
  
  if  is-list? crumb and length crumb > 1 
  [
    if path-clear (list pxcor pycor) (list item 0 crumb  item 1 crumb) 0
    [
      face-nowrap patch item 0 crumb  item 1 crumb
      set breadcrumb-num next-crumb-num
if debug-mode = true [      show "moving along trail" ]
      stop
    ]
  ]
  
  ;; continue to the current crumb
  set crumb item breadcrumb-num  (item trail-id breadcrumb-trails)
;;  show (word "current crumb is: " crumb )
  if path-clear (list pxcor pycor) (list item 0 crumb  item 1 crumb) 0
  [
    face-nowrap patch item 0 crumb  item 1 crumb
    stop
  ]
  
;;  show (word "lost in a snowstorm - can't see breadcrumbs " breadcrumb-num " of " item trail-id breadcrumb-trails )
  ;; uhhhh...  face it anyway, i guess
  face-nowrap patch item 0 crumb  item 1 crumb
end



to set-direction [little-dude]
  ;; look directly to goal;  if no trouble within the next steps, go forward.  otherwise, look to the side a bit

  let all-clear true
  let currentheading [heading] of little-dude

  ;; sometimes the "blue sky" is wrong.
  let nextpatch [pcolor] of patch-ahead 1
  if not member? nextpatch  allowed-patches and  blue-sky-steps > 0 [
    set blue-sky-steps 0
    set hugging-edges-steps 10

  ]


  ;; we are not hugging an edge, check around for a good path.
  if hugging-edges-steps < 1 [
      ifelse blue-sky-steps < 1 [
         let mypaths possible-path-list little-dude  2 false
         if length mypaths = 0 [ set mypaths possible-path-list little-dude 0 false ]  ;; if there aren't good paths with some buffer, try again with no buffer
         face-longest-path little-dude mypaths
      ][
         set blue-sky-steps  blue-sky-steps - 1  ;; stay on the current course for a few steps

      ]
  ]


  ;;  should we try hugging and edge and following it out of this dead end?
  if (hugging-edges-steps > 0) [


      ask little-dude [
         set heading  currentheading
      ]


      ;; another solution would be to set up markers between the buildings, and when you can't see a building, look for a marker
      ;; a problem with edge creeping is that all of the workers are in a single trail, not using the width of the path

      ;; first, turn towards the item we are going around  (it is like keeping a hand on the wall)
      ;;ifelse (go-right? = true) [ left 45 ][ right 45 ]

      ;; creep the edge.  If you can't step forward, look right.  Only look one step ahead; eventually we will creep out to open space.
      set hugging-edges-steps hugging-edges-steps - 1
      if (turn-along-edge = false ) [
        ;; this guy is totally trapped, just give up.
        set color black
        set pcolor green
        show (word "trapped worker: " who)
        die
      ]

  ]

end  ;; set-direction


;; returns false if we are totally stuck
to-report turn-along-edge
    let nextpatch [pcolor] of patch-ahead 1
    let turn-counter 0
    while [not member? nextpatch  allowed-patches and turn-counter < 10] [
      ifelse (go-right? = true) [ 
         right 45
      ][ 
         left 45
      ]
      set nextpatch [pcolor] of patch-ahead 1
      set turn-counter turn-counter + 1
      
;;      hatch 1 [
;;        set size 0.01
;;        pen-down fd 15
;;        wait 1
;;        pen-erase bk 15
;;        die
;;      ]
    ]
    
   
    if (turn-counter = 10) [ 
      report false ]
    
    report true
end

