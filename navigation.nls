;;
;; NAVIGATION
;;
;; a collection of functions that determine how breadcrumbs 
;; are made and how workers move along the breadcrumb trail.
;;
;;


;;
;; blaze-trail
;;
;; calls create-breadcrumbs 5 times, returns the shortest path
;;
to-report blaze-trail [src dst bold]
    let besttrail (list 0 0 0 100000)
    let newtrail (list 0 0 0 1000)
    foreach [1 2 3 4 5] [
       set newtrail create-breadcrumbs src dst bold  
       if length newtrail > 6 and item 3 newtrail < item 3 besttrail 
       [ set besttrail newtrail ]
    ]
    report besttrail
end

;;
;; create-breadcrumbs-from_buildinglist
;;
;; AFTER building list is built,
;; AFTER buildings are all drawn,
;; BEFORE workers are created
;;
to create-breadcrumbs-from_buildinglist
  
    foreach building-list [
      let buildnum  item 0 ?
      let dest item 7 ?

      ;; make sure there is a breadcrumb trail for every destination
      foreach dest [
        if not trail-exists buildnum ? true [
            let newtrail blaze-trail buildnum ? true
            if length newtrail > 6 [
               set breadcrumb-trails lput newtrail breadcrumb-trails
            ]
        ]
        if not trail-exists buildnum ? false [
            let newtrail blaze-trail buildnum ? false
            if length newtrail > 6 [
              set breadcrumb-trails lput newtrail breadcrumb-trails
            ]
        ]
      ]
    ]  
end

;;
;; trail-exists
;;
;; do we have breadcrumbs for this trail?
;;
to-report trail-exists [src dst bold]
  foreach breadcrumb-trails [
    if item 0 ? = src and item 1 ? = dst and item 2 ? = bold 
    [ report true ]
    if item 1 ? = src and item 0 ? = dst and item 2 ? = bold
    [ report true ]
  ]  
  report false
end

;;
;; create-breadcrumbs
;;
;; returns an arrary of [src dst bold length [x,y] [x,y] [x,y]...]
;;
to-report create-breadcrumbs [src dst bold]
  let breadcrumbs (list src dst bold 0)
  let show-test-msgs false
  let stop-spinning 800
  
  create-scout src dst bold true
  
  ask scouts
  [
    
       ;; march until we find the building or we have gone in 1000 circles
       while [[building-number] of patch-ahead 1 != dst and length breadcrumbs < stop-spinning] [
         let lastheading heading
         
         ;; decide where to go, and get there
         move-scout-one-step
         
         ;; add our current position to the list of breadcrumbs.  we can skip this if there was no change in direction
        ;; if lastheading != heading [
             set breadcrumbs add-breadcrumb breadcrumbs
        ;; ]

       ]
       set breadcrumbs lput (list pxcor pycor) breadcrumbs  ;; add final point to the list

       ;; optimize the list (unless we hit 1000 points and gave up)
       if length breadcrumbs < stop-spinning [
         let index 4
         while [index + 2 < length breadcrumbs] [
           set breadcrumbs optimize-breadcrumbs breadcrumbs index  ;; start at 5th item, first four are not points
           set index index + 1
         ] 
       ]
       
       if length breadcrumbs > 4 and length breadcrumbs < stop-spinning [
         ;; measure the list
         let pathlength measure-breadcrumb-trail breadcrumbs
         set breadcrumbs replace-item 3 breadcrumbs pathlength
       ]       
       ;; done with this temp, kill him
       die
  ]  
  
  if length breadcrumbs > stop-spinning - 1 or length breadcrumbs < 6 [
     ;; show "scout is lost, send someone else"
     set breadcrumbs []
  ]
  
  report breadcrumbs
end   ;; create-breadcrumbs


;;
;; measure-breadcrumb-trail
;;
;; pass in a breadcrumb trail, return a total length
;; used in turtle context
;;
to-report measure-breadcrumb-trail [trail]
   let thelength 0
   hatch 1 [

      let pt1 item 4 trail
      setxy  item 0 pt1 item 1 pt1
      
      foreach trail [
        if is-list? ? [
          set thelength thelength + distancexy item 0 ? item 1 ?
          move-to patch item 0 ? item 1 ?
        ]
      ]
      die;
   ]
   
   report thelength
end

;;
;; move-scout-one-step
;;
;; tell a scout to look around and decide where to move, and go there
;; uses the range of possible paths and chooses the best, or it hugs an edge.
;; 
;;
to move-scout-one-step
  
     ;; first check for a nice clear path with a buffer, then try a clear skinny path
     let mypaths []
     if hugging-edges-steps < 1 [
       ;; get list of all possible paths
       set  mypaths possible-path-list self 2 false
       if length mypaths = 0 [ 
         set mypaths possible-path-list self 0 false
       ]  ;; if there aren't good paths with some buffer, try again with no buffer
     ]
     
     ;; if we dont have a path, start hugging the edge
     if length mypaths = 0 and hugging-edges-steps < 1
     [ set hugging-edges-steps 9 ] 
     
     
     ifelse hugging-edges-steps > 0[
       ;; there are no paths, hug the edges, turn towards the next step
       set hugging-edges-steps hugging-edges-steps - 1
       let ret turn-along-edge  
     ][
       ;; choose the best path, and turn towards the next step
       let myheading bestheading-path mypaths
       set heading myheading
     ]
     
     ;; double-check to see if it is a safe step, and move one.
     let nextpatchcolor [pcolor] of patch-ahead 1
     if ( member? nextpatchcolor  allowed-patches) 
     [ forward 1 ]
     
     
end

;;
;; optimize-breadcrumbs
;;
;; look at three points starting at index.  If there is a direct path 
;; from the first to third, remove the second.  And repeat.
;; returns the shortened breadcrumbs 
to-report optimize-breadcrumbs [breadcrumbs index]
  
  if index + 2 < length breadcrumbs [
    
    let pt1 item index breadcrumbs
    let pt2 item (index + 2) breadcrumbs
    
    if path-clear pt1 pt2 2 = true [
      ;; remove the point that is not needed, recurse deeper in.
      set breadcrumbs remove-item (index + 1) breadcrumbs
      set breadcrumbs optimize-breadcrumbs breadcrumbs index
    ]
    
  ]

  report breadcrumbs
end

;;
;; draw-breadcrumb-trail
;;
;; only used for diagnostic purposes.  does not affect how the workers move.
;; note that all workers are dead at the end of this, so call it before setting up workers.
;;

to draw-breadcrumb-trail [path]
without-interruption [  
  
  create-scout 1 1 1 1
  
  if length path > 4 [
    
    let pt1 item 4 path
    ask scouts [ 
      set color random (9) * 10 + 5
      setxy  item 0 pt1 item 1 pt1
      pen-down 
    ]
    
    foreach path [
      if is-list? ? [
        ask scouts [ move-to patch item 0 ? item 1 ?  ]
      ]
    ]
  ]
  
  ask scouts [ die ]
]
end  ;; draw-breadcrumb-trail

;;
;; path-clear
;;
;; create a temporary worker to walk from one point to the second, and see if there is anything in the way
;;
;; returns true/false
;; 
to-report path-clear [pt1 pt2 radius]
  let isclear true 
  let dude who
  let debug-mode false
  if who = -1 [set debug-mode true]
  hatch 1 [ 
    if debug-mode = true [show (word "hatched a who " who )]
    ;; move our guy to the first breadcrumb, and look at the next
    if debug-mode = true [
      show (word pt1 pt2 )
      setxy item 0 pt2 item 1 pt2 
;;      set size 0.1 
      set color red 
      ;;pen-down 
      show (word "src: " pt1 " dest: " pt2)
      show (word "allowed colors: " allowed-patches)
     ]  ;; show the line
    setxy  item 0 pt1 item 1 pt1
    if debug-mode = true [pen-up]
    face-nowrap patch item 0 pt2 item 1 pt2
    let dist distancexy  item 0 pt2 item 1 pt2
    if debug-mode = true [ show dist ]
    let step-counter 1                              ;; count steps along the path that is being examined
    
   
    ;; if (not is-allowed-patch patch-ahead step-counter 2 allowedpatches)
    while [step-counter < dist + 1 and isclear = true] [
      if debug-mode = true [
;;        show ( word patch-ahead step-counter " "  [pcolor] of patch-ahead step-counter) 
;;        show is-allowed-patch patch-ahead step-counter radius
        
      ]
      if  patch-ahead step-counter = patch item 0 pt2 item 1 pt2 [ die report isclear]
      set step-counter step-counter + 1
      
      if ( is-allowed-patch patch-ahead step-counter radius = false) [
        if debug-mode = true [
          show (word "problem " step-counter " steps ahead at patch " patch-ahead step-counter " colour " [pcolor] of patch-ahead step-counter)
          show (word "from patch " pt1 " to patch " pt2 " only using " allowed-patches)
        ]
        set isclear false
      ]
    ]
    
    ;; diagnostic 
    if isclear = true and debug-mode = true [
      ;;pen-down
      set color blue
      move-to patch item 0 pt2 item 1 pt2
    ]
    
    die
  ]

  report isclear
end


;;
;; bestheading-path
;;
;; receives a list of [heading distance] options
;; returns heading with the longest distance
;;
to-report bestheading-path [mypaths]
  
   let myheading  heading
   let step-count  0
   foreach mypaths [
     if  item 1 ? > step-count [
       set myheading  item 0 ?
       set step-count  item 1 ?
     ]
   ]
   report myheading
end

;;
;; add-breadcrumb
;;
;; adds the current location of the current worker to the end of the breadcrumbs array
;; returns the breadcrumbs
;;
to-report add-breadcrumb [breadcrumbs]
   set breadcrumbs lput (list pxcor pycor) breadcrumbs
   report breadcrumbs
end


;;
;; show-planned-path
;;
;; helper function - sketch the path we plan to follow
;; visible lines do not affect how turtles move - the patch color under the path is not changed.
;;
to show-planned-path [steps]
       if steps > 0  [
         hatch 1 [
           set color blue
           set size 0.01
           ;; pen-down fd steps
          ;; wait 1
          ;; pen-erase bk steps
           die
         ]]
end


;;
;; select-breadcrumbs [ src dest bold ]
;;
;; Called when a worker picks a destination, or changes direction.
;; returns an array of (pathindex reversed point)
;; where point is the position in the array of points
;;
to-report select-breadcrumbs [src dest bold ]
   let ndx 0
  
   foreach breadcrumb-trails
   [ 
      if src = item 0 ? and dest = item 1 ? and bold = item 2 ? [ report ( list ndx false 4) ]
      if src = item 1 ? and dest = item 0 ? and bold = item 2 ? [ report ( list ndx true (length ? - 1)) ]
      set ndx ndx + 1
   ]
   report (list )
end


;;
;; follow-the-yellow-brick-road
;;
;; face the next breadcrumb, and don't step on each other.
;;
to follow-the-yellow-brick-road
  let debug-mode false
  if who = -1 [set debug-mode true]
  
  ;; are we still playing?
  if color = black [ stop ]


  ;; can we see the actual goal?
  if path-clear (list pxcor pycor) (list [pxcor] of goal [pycor] of goal) 0 = true
  [
    if debug-mode [
      show (word "it thinks the path is clear to the goal.  " item trail-id breadcrumb-trails )
    ]
    face-nowrap goal
    stop
  ]
  
  if breadcrumb-num < 4
  [
    ;; there are no crumbs if there is a direct path between buildings.  but we might be in a corner somewhere.
    if debug-mode [ show (word "no crumbs, and can't see goal, stuck in a weird corner " pxcor "," pycor " " goal)]
    ;; todo - select a new dest square, at random, or pick a new place in the current building
    stop
  ] 
  
;;  show (word "on patch " pxcor ", " pycor " using crumb " breadcrumb-num)

  ;; grab the crumb we are looking for
  let crumb item breadcrumb-num  (item trail-id breadcrumb-trails)
  
  ;; can we see the  crumb ahead?
  if next-crumb-in-sight? = true [
      set crumb item breadcrumb-num  (item trail-id breadcrumb-trails)
      face-nowrap patch item 0 crumb  item 1 crumb
      stop
  ]
  
  ;; continue to the current crumb
  set crumb item breadcrumb-num  (item trail-id breadcrumb-trails)
;;  show (word "current crumb is: " crumb )
  if path-clear (list pxcor pycor) (list item 0 crumb  item 1 crumb) 0
  [
    face-nowrap patch item 0 crumb  item 1 crumb
    stop
  ]
  
;;  show (word "lost in a snowstorm - can't see breadcrumbs " breadcrumb-num " of " item trail-id breadcrumb-trails )
  ;; uhhhh...  face it anyway, i guess
  if not is-list? crumb [show "this isn't even a crumb.  so crumby"]
  face-nowrap patch item 0 crumb  item 1 crumb
end


;;  
;; next-crumb-in-sight?
;; returns true/false
;;
;;  Tells us if there is a clear path to the next crumb, so we can update how far along the trail we are.
;;  NOTE:  this function will update the breadcrumb-num for the worker if the next crum is in sight
;;
to-report next-crumb-in-sight? 
  
  let thiscrumb item breadcrumb-num  (item trail-id breadcrumb-trails)
  
  ;; get the next crumb in the trail
  let next-crumb-num breadcrumb-num + 1
  if breadcrumb-reverse = true [set next-crumb-num breadcrumb-num - 1]
  let nextcrumb []
  if next-crumb-num < length item trail-id breadcrumb-trails [
     set nextcrumb item next-crumb-num ( item trail-id breadcrumb-trails)
  ]

  if not is-list?  nextcrumb or  length nextcrumb < 2 [ report false ]  ;; this is not a crumb, abort mission
  
  ;; stay to the right of the breadcrumb trail - if the trail ahead curves to the left, stay on the trail and don't cut the corner
  face-nowrap patch item 0 thiscrumb  item 1 thiscrumb
  let current-heading heading
  face-nowrap patch item 0 nextcrumb  item 1 nextcrumb
  let next-heading heading
  ;;show (word "heading: " current-heading " turning to " next-heading)
  if next-heading < current-heading
  [
    ;; is it more than a step away?
    if item 0 thiscrumb = pxcor and item 1 thiscrumb = pycor [
;;    if item 0 thiscrumb - pxcor < -1 or item 0 thiscrumb - pxcor > 1 [
;;      if item 1 thiscrumb - pycor < -1 or item 1 thiscrumb - pycor > 1 [
         report false
      ]
;;    ]
;;  ]
   ]

  ;; see if we have a clear path
  if  is-list? nextcrumb and length nextcrumb > 1 
  [
    if path-clear (list pxcor pycor) (list item 0 nextcrumb  item 1 nextcrumb) 0
    [
      set breadcrumb-num next-crumb-num
      report true
    ]
  ]
    
  ;; nope.  
  report false
end


;; returns false if the scout is totally stuck
to-report turn-along-edge
    let nextpatch [pcolor] of patch-ahead 1
    let turn-counter 0
    while [not member? nextpatch  allowed-patches and turn-counter < 10] [
      ifelse (go-right? = true) [ 
         right 45
      ][ 
         left 45
      ]
      set nextpatch [pcolor] of patch-ahead 1
      set turn-counter turn-counter + 1
      
;;      hatch 1 [
;;        set size 0.01
;;        pen-down fd 15
;;        wait 1
;;        pen-erase bk 15
;;        die
;;      ]
    ]
    
   
    if (turn-counter = 10) [ 
      report false ]
    
    report true
end

