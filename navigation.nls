
to create-breadcrumbs [src dst]
  
  ;; create temp worker
  let buildnum  src
  create-workers 1 [
      move-to one-of patches with [building-number = src]
      init-worker red red (list dst) src 1 1 1
  ]
  
  ask workers
  [
    
       pen-down

       while [[building-number] of patch-ahead 1 != dst] [
         
         
         ;; get list of all possible paths
         let mypaths possible-path-list self
         
         
         ifelse length mypaths = 0 [
           ;; there are no paths, hug the edges.
           set hugging-edges-steps 10;
           show "trapped";
           stop 
         ][
           ;; look for the longest path, grab that angle
           let myheading  heading
           let step-count  0
           foreach mypaths [
             if  item 1 ? > step-count [
               set myheading  item 0 ?
               set step-count  item 1 ?
               if item 1 ? > 23 [
                 set blue-sky-steps 20
               
               ]
             ]
           ]
           if myheading != heading [
             ;; altering course, this is a breadcrumb
             set pcolor red
             set heading myheading
             show-planned-path blue-sky-steps
           ]
         ]
         
         
         forward 1
         
       ]
       
       
  ]  
  
  ;; calculate destinations
  ;; save destinations in list
  
  
end

;; helper function - sketch the path we plan to follow
to show-planned-path [steps]
       if steps > 0  [
         hatch 1 [
           set color blue
           set size 0.01
           pen-down fd steps
          ;; wait 1
          ;; pen-erase bk steps
           die
         ]]
end



to set-direction [little-dude]
  ;; look directly to goal;  if no trouble within the next steps, go forward.  otherwise, look to the side a bit

  let all-clear true
  let currentheading [heading] of little-dude

  ;; sometimes the "blue sky" is wrong.
  let nextpatch [pcolor] of patch-ahead 1
  if not member? nextpatch  allowed-patches and  blue-sky-steps > 0 [
    set blue-sky-steps 0
    set hugging-edges-steps 10

  ]


  ;; we are not hugging an edge, check around for a good path.
  if hugging-edges-steps < 1 [
      ifelse blue-sky-steps < 1 [
         let mypaths possible-path-list little-dude
         face-longest-path little-dude mypaths
      ][
         set blue-sky-steps  blue-sky-steps - 1  ;; stay on the current course for a few steps

      ]
  ]


  ;;  should we try hugging and edge and following it out of this dead end?
  if (hugging-edges-steps > 0) [


      ask little-dude [
         set heading  currentheading
      ]


      ;; another solution would be to set up markers between the buildings, and when you can't see a building, look for a marker
      ;; a problem with edge creeping is that all of the workers are in a single trail, not using the width of the path

      ;; first, turn towards the item we are going around  (it is like keeping a hand on the wall)
      ;;ifelse (go-right? = true) [ left 45 ][ right 45 ]

      ;; creep the edge.  If you can't step forward, look right.  Only look one step ahead; eventually we will creep out to open space.
      set nextpatch [pcolor] of patch-ahead 1
      let step-counter 0
      while [not member? nextpatch  allowed-patches and step-counter < 10] [
        ifelse (go-right? = true) [
           right 45
        ][
           left 45
        ]
        set nextpatch [pcolor] of patch-ahead 1
        set step-counter step-counter + 1
      ]

      set hugging-edges-steps hugging-edges-steps - 1

      ;; this guy is totally trapped, just give up.
      if (step-counter = 10) [
        set color black
        set pcolor green
        show (word "trapped worker: " who)
        die
      ]

  ]

end



