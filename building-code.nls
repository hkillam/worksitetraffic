
;; indicies in the array building-list
globals [
 I-ID      ;; 0
 I-Dest    ;; 7
 I-Center  ;; 15
]

; 
; create-buildinglist
;
; reads the xlsx file, creates an array of buildings
;
to create-buildinglist
    let temp-building-list csv:from-file "buildings.csv"  
    
    
    let firstrow item 0 temp-building-list
    if item 0 firstrow = "facility" [ set temp-building-list remove-item 0 temp-building-list]

    foreach temp-building-list [
      let buildnum  item 0 ?
      let dest item 7 ?
      let mud-slows 0
      if item 8 ? > 0 or item 9 ? > 0 
      [ set mud-slows 1 ]
      let danger-harms item 10 ?
      
      ;; check destination(s) for a single value or a list
      ;; currently, this only works for two destinations.  need to loop for more than two
      ifelse (member? "," (word dest)) [
        let comma position "," dest
        let desta read-from-string substring dest 0 comma
        let destb read-from-string substring dest (comma + 1) (length dest)
        set dest list desta destb
      ]  [
        set dest (list dest)
      ]
      
      ;; update the building array
      let new-building replace-item 7 ? dest
      set new-building lput patch item 2 ? item 3 ? new-building  ;; index 13 is the center of the building, and we will reset this when the building is created/moded
      let worker-zone (min (list item 4 ? item 5 ? ) / 2 ) - 2
      set new-building lput worker-zone new-building  ;; index 14  ;; keep workers in this radius around the center

      set building-list lput new-building building-list
    ]
    
end



to-report building-stats [building-num]
    let bx1 min [pxcor] of patches with [building-number = building-num]
    let by1 min [pycor] of patches with [building-number = building-num]
    let bwid max [pxcor] of patches with [building-number = building-num] - bx1
    let blen max [pycor] of patches with [building-number = building-num] - by1

    let avoiders count turtles with [avoid-mud? = 1 and home-building = building-num]
    let bold count turtles with [avoid-mud? = 0 and home-building = building-num]
    let avoiders-trips  mean [trips-completed] of  turtles with [avoid-mud? = 1 and home-building = building-num]
    let bold-trips  mean [trips-completed] of  turtles with [avoid-mud? = 0 and home-building = building-num]
    let avoiders-triptime 0
    if avoiders-trips > 0 [ set avoiders-triptime total-ticks / avoiders-trips ]
    let bold-triptime 0
    if bold-trips > 0 [ set bold-triptime  total-ticks / bold-trips]

    let napper-trips 0
    set napper-trips mean  [no-energy-tick] of workers with [no-energy-tick > 0 and building-num = home-building]

    report (list building-num bx1 by1 bwid blen avoiders bold avoiders-trips bold-trips avoiders-triptime bold-triptime napper-trips)
end

;;
;; center-of
;;
;; find the building info, return the center
;;
to-report center-of [ building-num]
  foreach building-list [
    if building-num = item 0 ? [
      if not is-patch? item 15 ? [
        report reset-center-of-building building-num
      ]
      report item 15 ?
    ]
  ]
  
  ;; 1 doesn't appear in the list, just look it up.
  if building-num = 1
  [
      report reset-center-of-building building-num
  ]
  
  ;; this should not be possible.  but just in case.
  report patch 1 1
end

;;
;; worker-radius
;;
;; find the building info, return the radius where workers should start
;;
to-report shoot-a-dart [ building-num]
  let theradius 15
  let thedart one-of patches with [building-number = building-num]
  
  ;; look up the radius
  foreach building-list [
    if building-num = item 0 ? [
      set theradius item 16 ?
      
    ]
  ]
  
  ;; find the center, ask a patch near the center to volunteer
  sprout 1  [
    move-to center-of building-num
    set thedart one-of patches in-radius theradius
    die
  ]
  
  report thedart
    
end

;;
;; find-center-of-building
;;
;; look on map to see building center of current building location, update the array of building info
;;
to-report reset-center-of-building [building-num]
;; another option is nearest block in building    
;; min-one-of patches with [ building-number = [destination-building] of myself ] [ distance myself ]
    let bx1 min [pxcor] of patches with [building-number = building-num]
    let by1 min [pycor] of patches with [building-number = building-num]
    let bx2 max [pxcor] of patches with [building-number = building-num]
    let by2 max [pycor] of patches with [building-number = building-num]
    let bxcenter mean list bx1 bx2
    let bycenter mean list by1 by2

    let ndx 0
    foreach building-list [
      if building-num = item 0 ? [
            let new-building replace-item 15  ? patch bxcenter bycenter  ;; index 15 is the center of the building, and we will reset this when the building is created/moded
            set building-list replace-item ndx building-list new-building
      ]
      set ndx ndx + 1
    ]
    
    report patch bxcenter bycenter
end

;;to-report mouse-clicked2?
;;  report (mouse-was-down? = true and not mouse-down?)
;;end



;;
;; move-building
;;
;; If the UI button "move building" is down, respond to a mouse click. 
;; Move the bottom left corner of the building to the point where the mouse was clicked.  Replace with "path". 
;;
to move-building
  
  ;; respond after a mouse click is released
  if mouse-down? [ set mouse-was-down? true ]
  if mouse-was-down? = true and not mouse-down? [
    set mouse-was-down? false 
 
    without-interruption [
         let temp-building-width 20
         let temp-building-height 20

         ;; grab the building size, and clear the old building
         ask patches with [building-number = building-to-move] [
           set pcolor  clr-path
           set building-number  0
           set temp-building-width  building-width
           set temp-building-height building-height

         ]

         ;; create the new building
         let x2  mouse-xcor + temp-building-width
         let y2   mouse-ycor + temp-building-height
         construct-hovel building-to-move mouse-xcor mouse-ycor x2 y2
         
         ;; delete old breadcrumbs, make new ones.  People too, we need them cleared to make breadcrumbs.
         ask workers [ die ]
         set breadcrumb-trails []
         create-breadcrumbs-from_buildinglist
         setup-workers

         ;; before execution, move workers to their building.  If already executing, reset their directions.
         ifelse ticks = 0 [
           ask workers with [home-building = building-to-move][
              move-to one-of patches with [building-number = building-to-move]
           ]
         ][
            redirect-workers
         ]
         stop
       ]
  ]

end


to construct-hovel [building-num x1 y1 x2 y2]
  without-interruption
  [
   ask patches with [pxcor >= x1 and pxcor <= x2 and  pycor >= y1 and pycor <= y2]
   [
     set pcolor  clr-moveable-facility
     set building-number  building-num
     set building-width x2 - x1
     set building-height y2 - y1
   ]

   let center reset-center-of-building building-num  ;; find it, update the record

   ask patches with [pxcor = x1 + 5 and pycor = y1 + 5]
   [
     set plabel-color black
     set plabel building-num
   ]
  ]
end


to-report work-time [building-num]
  foreach building-list [
    if building-num = item 0 ? [
      let min-time item 11 ?
      let range item 12 ? - item 11 ?
      let the-time random (range) + min-time
      report the-time
    ]
  ]

  report 0
end


to draw-mainbuilding 
  ask patches with [pxcor >= 71 and pycor >= 108 and pxcor <= 114 and pycor <= 149]
  [set pcolor clr-fixed-facility
    set building-number 1]   
end

;;
;; make-buildings-from-list
;;
;; Check out the list, create the buildings.  Caled from Startup
;;
to  make-buildings-from-list[  ]
  foreach building-list [
    let buildnum  item 0 ?
    if buildnum != "facility" [
      let buildname  item 1 ?
      let x1  item 2 ?
      let y1  item 3 ?
      let width  item 4 ?
      let height  item 5 ?
      let x2  x1 + width
      let y2  y1 + height

      construct-hovel buildnum x1 y1 x2 y2
    ]
  ]
  draw-mainbuilding 
  
end

