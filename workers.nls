;;
;; WORKERS
;;
;; describe workers and store information
;; functions to create and direct them
;;

breed [ workers ]

globals [
  group-history   ;; an array for each group:  source, dest, bold, num-in-group, list of trip counts at each tick
  I-grpsrc
  I-grpdst
  I-grpavoider
  I-grpcount
]


workers-own [
  searching?            ;; 1 if going to the materials, 0 if returning\
  energy                ;; start at tick-count, at zero just quit
  allowed-patches       ;; colours of patches this guy can step on - will replace "losest-road"
  avoid-mud?            ;; 1 to go around mud, 0 to go through it
  trips-completed       ;; number of round-trip journies
  home-building         ;; place this worker starts out
  destination-building  ;; number of the building they are currently heading to
  goal                  ;; random space within the building they are heading to
  previous-patch        ;; last place this dude was standing
  dice-tossed?          ;; for people in the danger zone, toss the dice once per trip
  no-energy-tick        ;; the tick count when this worker runs out of energy (group 2 - tired in mud)
  go-right?             ;; true if this turtle looks to the right for an open route.  set this when the goal is set
  hugging-edges-steps   ;; if the turtle starts hugging the edge, this is how many more steps to do it for
  blue-sky-steps        ;; if we are wandering in open spaces, take a few steps before re-calculating
  slow-in-mud?          ;; from the input file - how is the worker affected by mud
  tired-in-mud?         ;; from the input file - how is the worker affected by mud
  risk-danger?          ;; from the input file - how is the worker affected by mud
  working-ticks         ;; count down how long a worker stays in a work building
  trail-id              ;; which string of breadcrumbs is he following
  breadcrumb-reverse    ;; true if starting at end and going to beginning
  breadcrumb-num        ;; how far along the string of breadcrumbs is he
  injured?              ;; has this worker been injured?
]


;;
;; setup-workers
;;
;; called from setup function to read building list and generate all of the workers
;;
to setup-workers
  set I-grpsrc   0
  set I-grpdst   1
  set I-grpavoider  2
  set I-grpcount 3
  set group-history []

  foreach building-list [
    let buildnum  item I-ID ?
    if buildnum != "facility" [
      let buildname  item I-Name ?
      let numworkers  item I-NumWorkers ? 
      let dest item I-Dest ?

      ;; how does mud/danger affect workers from this building?
      let mud-slows item I-MudSlows ?
      let mud-tires item I-MudTires ?
      let danger-harms item I-Harm ?

      create-workers numworkers [
        move-to one-of patches with [building-number = buildnum]
        let color1 95
        let color2 85
        if (buildnum = 14) [ set color1 orange set color2 yellow ]
        if (buildnum = 18) [ set color1 95 set color2 85 ]
        if (buildnum = 15) [ set color1 115 set color2 125  ]
        init-worker color1 color2 dest buildnum mud-slows mud-tires danger-harms
      ]
      
      ;; create the list of group records
      if is-list? dest [
        foreach dest
        [
          let bold-workers count workers with [home-building = buildnum and destination-building = ? and avoid-mud? = 0]
          let avoiders count workers with [home-building = buildnum and destination-building = ? and avoid-mud? = 1]
          set group-history lput  (list buildnum ? 1 bold-workers) group-history
          set group-history lput  (list buildnum ? 0 avoiders) group-history
        ]
      ]
    ]
  ]

end


;;
;; record-group-stats
;;
;; For every tick, grab the current stats on each group (trips completed, tired workers)
;;
to record-group-stats
  let new-history []
  foreach group-history
  [
   ;; if (count workers with [avoid-mud? = item I-grpavoider ? and home-building = item I-grpsrc ? and destination-building = item I-grpdst ? ]) < 1
   ;; [
     ;; show (word "no turtles record-group.  home: " item I-grpsrc ? " dest: " item I-grpdst ? " avoider: " item I-grpavoider ?)
   ;; ]
    let sum-trips  sum [trips-completed] of  workers with [avoid-mud? = item I-grpavoider ? and home-building = item I-grpsrc ? and destination-building = item I-grpdst ? ]
    let avg-trips  mean [trips-completed] of  workers with [avoid-mud? = item I-grpavoider ? and home-building = item I-grpsrc ? and destination-building = item I-grpdst ? ]
    let retired count  workers with [energy <= 0 and injured? = false  and avoid-mud? = item I-grpavoider ? and home-building = item I-grpsrc ? and destination-building = item I-grpdst ?]
    let injured count  workers with [injured? = true  and avoid-mud? = item I-grpavoider ? and home-building = item I-grpsrc ? and destination-building = item I-grpdst ?]
    set new-history lput (lput (list ticks sum-trips  avg-trips retired injured) ?) new-history
  ]
  set group-history new-history
end

;;
;; write-worker-stats
;;
;; Create a file for each group, show all of the stats for every tick.
;;
to write-worker-stats
  ;; start with column headers
  let myheaders ["ticks" "total trips" "average trips" "retired" "injured"]
  

  foreach group-history
  [
     let myout (list myheaders)
     
     foreach ? [
       if is-list? ? [ set myout lput ? myout ]
     ]

     ;; create a filename, and write the results
     let filename (word "results-group" item I-grpsrc ? "to" item I-grpdst ?)
     ifelse item I-grpavoider ? = 1
     [ set filename (word filename "avoider.csv") ]
     [ set filename (word filename "bold.csv") ]
     csv:to-file filename myout
  ]
end


;;
;; write-worker-summaries
;;
;; Creates a file listing summaries for each group.  A group is workers who share the same source and dest.
;;
to write-worker-summaries
  ;; building stats
  let myheaders ["source building" "dest building" "number of avoiders" "number of bold workers" "average trips for avoiders" "average trips for bold" "average time per trip avoiders" "average time per trip bold" "average ticks mudders get tired"]
  let myout (list myheaders)

  foreach building-list [
    let buildnum  item I-ID ?
    foreach item I-Dest ?
    [
      let mystats group-stats  buildnum ?
      set myout lput mystats myout
    ]
  ]
  csv:to-file "results-groupstats.csv" myout

end



;;
;; init-worker
;;
;; Initializes a single worker, personality, destination.
;;
to init-worker [  colorA colorB dest-buildings home-plate mud-slows mud-tires danger-harms]
      let dest one-of dest-buildings
      set home-building home-plate
      set destination-building dest
      set size 1
      set breed workers
      set injured? false
      set trips-completed 0
      set energy total-ticks
      set avoid-mud? one-of [0 1]
      ifelse avoid-mud? = 0
      [  
         set-worker-bold colorA danger-harms
      ][
         set-worker-avoider colorB
      ]


      set no-energy-tick 0

      set-new-destination dest 1 0
      set blue-sky-steps 0
      set slow-in-mud? mud-slows
      set tired-in-mud? mud-tires
      set risk-danger? danger-harms
end

;;
;; set-worker-bold
;;
;; give a worker "bold" properties, charging through mud, laughing at danger, unstoppable (unless it's mother calls)
;;
to set-worker-bold [colorA danger-harms]
   set allowed-patches (list clr-path clr-road clr-moveable-facility )   ;; add red for testinng breadcrumbs
   set allowed-patches lput clr-mud allowed-patches
   set color colorA
   if danger-harms = 1 [
     set allowed-patches lput clr-danger allowed-patches
   ]
    ;; new requirement in December - let the main building be a possible destination.
    if destination-building = 1 [
         set allowed-patches lput clr-fixed-facility allowed-patches
    ]
end

;;
;; set-worker-avoider
;;
;; give a worker "avoider" properties, going around mud or danger
;;
to set-worker-avoider [colorB]
  set allowed-patches (list clr-path clr-road clr-moveable-facility  red )
  set color colorB
  ;; new requirement in December - let the main building be a possible destination.
  if destination-building = 1 [
       set allowed-patches lput clr-fixed-facility allowed-patches
  ]
end



;;
;; set-new-destination
;;
;; called when:  create people, arrive at destination, buildings move
;;
to set-new-destination [new-dest new-searching add-trip ]
      let thegoal one-of patches with [building-number = new-dest]
      ask patch pxcor pycor [
         set thegoal shoot-a-dart new-dest
      ]
      set goal thegoal
      face goal
      set searching?  new-searching
      set trips-completed trips-completed + add-trip
      set previous-patch patch 0 0
      set dice-tossed? 0
      set hugging-edges-steps 0
      set blue-sky-steps 0

      ;; tell turtle which direction it will need to turn to go away from the center
      let centerheading towardsxy 105 105
      ifelse (subtract-headings centerheading heading > 0) [
        set go-right? false
      ] [
        set go-right? true
      ]
      
      ;; choose a trail of breadcrumbs
      let bold 1
      if avoid-mud? = true or avoid-mud? = 1 [ set bold 0 ]
      let src home-building
      if new-dest = home-building [set src destination-building]
      let crumbly select-breadcrumbs src new-dest bold

      if length breadcrumb-trails > 6 [
         if length crumbly > 2 [
           let mytrail item (item 0 crumbly) breadcrumb-trails
         ]
      ]
      
      if length crumbly > 2 [
        set trail-id item 0 crumbly     
        set breadcrumb-reverse item 1 crumbly     ;; true/false
        set breadcrumb-num item 2 crumbly    
      ]
end


