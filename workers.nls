;;
;; WORKERS
;;
;; describe workers and store information
;; functions to create and direct them
;;

breed [ workers ]

globals [
  group-history   ;; an array for each group:  source, dest, bold, num-in-group, list of trip counts at each tick
  I-grpsrc
  I-grpdst
  I-grpbold
  I-grpcount
]


workers-own [
  searching?            ;; 1 if going to the materials, 0 if returning\
  energy                ;; start at tick-count, at zero just quit
  allowed-patches       ;; colours of patches this guy can step on - will replace "losest-road"
  avoid-mud?            ;; 1 to go around mud, 0 to go through it
  trips-completed       ;; number of round-trip journies
  home-building         ;; place this worker starts out
  destination-building  ;; number of the building they are currently heading to
  goal                  ;; random space within the building they are heading to
  previous-patch        ;; last place this dude was standing
  dice-tossed?          ;; for people in the danger zone, toss the dice once per trip
  no-energy-tick        ;; the tick count when this worker runs out of energy (group 2 - tired in mud)
  go-right?             ;; true if this turtle looks to the right for an open route.  set this when the goal is set
  hugging-edges-steps   ;; if the turtle starts hugging the edge, this is how many more steps to do it for
  blue-sky-steps        ;; if we are wandering in open spaces, take a few steps before re-calculating
  slow-in-mud?          ;; from the input file - how is the worker affected by mud
  tired-in-mud?         ;; from the input file - how is the worker affected by mud
  risk-danger?          ;; from the input file - how is the worker affected by mud
  working-ticks         ;; count down how long a worker stays in a work building
  trail-id              ;; which string of breadcrumbs is he following
  breadcrumb-reverse    ;; true if starting at end and going to beginning
  breadcrumb-num        ;; how far along the string of breadcrumbs is he
  injured?              ;; has this worker been injured?
]


;;
;; setup-workers
;;
;; called from setup function to read building list and generate all of the workers
;;
to setup-workers
  set I-grpsrc   0
  set I-grpdst   1
  set I-grpbold  2
  set I-grpcount 3
  set group-history []

  foreach building-list [
    let buildnum  item I-ID ?
    if buildnum != "facility" [
      let buildname  item I-Name ?
      let numworkers  item I-NumWorkers ? 
      let dest item 7 ?

      ;; how does mud/danger affect workers from this building?
      let mud-slows item 8 ?
      let mud-tires item 9 ?
      let danger-harms item 10 ?

      create-workers numworkers [
        move-to one-of patches with [building-number = buildnum]
        let color1 95
        let color2 85
        if (buildnum = 14) [ set color1 orange set color2 yellow ]
        if (buildnum = 18) [ set color1 95 set color2 85 ]
        if (buildnum = 15) [ set color1 115 set color2 125  ]
        init-worker color1 color2 dest buildnum mud-slows mud-tires danger-harms
      ]
      
      ;; create the list of group records
      if is-list? dest [
        foreach dest
        [
          let bold-workers count workers with [home-building = buildnum and destination-building = ? and avoid-mud? = 0]
          let avoiders count workers with [home-building = buildnum and destination-building = ? and avoid-mud? = 1]
          set group-history lput  (list buildnum ? 1 bold-workers) group-history
          set group-history lput  (list buildnum ? 0 avoiders) group-history
        ]
      ]
    ]
  ]

end


;;
;; record-group-stats
;;
;; For every tick, grab the current stats on each group (trips completed, tired workers)
;;
to record-group-stats
  let new-history []
  foreach group-history
  [
    let sum-trips  sum [trips-completed] of  turtles with [avoid-mud? = item I-grpbold ? and home-building = item I-grpsrc ? and destination-building = item I-grpdst ? ]
    let avg-trips  mean [trips-completed] of  turtles with [avoid-mud? = item I-grpbold ? and home-building = item I-grpsrc ? and destination-building = item I-grpdst ? ]
    let retired count  turtles with [energy <= 0 and avoid-mud? = item I-grpbold ? and home-building = item I-grpsrc ? and destination-building = item I-grpdst ?]
    let injured count  turtles with [injured? = true  and avoid-mud? = item I-grpbold ? and home-building = item I-grpsrc ? and destination-building = item I-grpdst ?]
    set new-history lput (lput (list ticks sum-trips  avg-trips retired injured) ?) new-history
  ]
  set group-history new-history
end

;;
;; write-worker-stats
;;
;; Create a file for each group, show all of the stats for every tick.
;;
to write-worker-stats
  ;; start with column headers
  let myheaders ["ticks" "total trips" "average trips" "retired" "injured"]
  

  foreach group-history
  [
     let myout (list myheaders)
     
     foreach ? [
       if is-list? ? [ set myout lput ? myout ]
     ]

     ;; create a filename, and write the results
     let filename (word "results-group" item I-grpsrc ? "to" item I-grpdst ?)
     ifelse item I-grpbold ? = 1
     [ set filename (word filename "bold.csv") ]
     [ set filename (word filename "avoider.csv") ]
     csv:to-file filename myout
  ]
end



;;
;; init-worker
;;
;; Initializes a single worker, personality, destination.
;;
to init-worker [  colorA colorB dest-buildings home-plate mud-slows mud-tires danger-harms]
      let dest one-of dest-buildings
      set home-building home-plate
      set destination-building dest
      set size 1
      set breed workers
      set injured? false
      set trips-completed 0
      set energy total-ticks
      set avoid-mud? one-of [0 1]
      ifelse avoid-mud? = 0
      [  
         set-worker-bold colorA danger-harms
      ][
         set-worker-avoider colorB
      ]


      set no-energy-tick 0

      set-new-destination dest 1 0
      set blue-sky-steps 0
      set slow-in-mud? mud-slows
      set tired-in-mud? mud-tires
      set risk-danger? danger-harms
end

;;
;; set-worker-bold
;;
;; give a worker "bold" properties, charging through mud, laughing at danger, unstoppable (unless it's mother calls)
;;
to set-worker-bold [colorA danger-harms]
   set allowed-patches (list clr-path clr-road clr-moveable-facility )   ;; add red for testinng breadcrumbs
   set allowed-patches lput clr-mud allowed-patches
   set color colorA
   if danger-harms = 1 [
     set allowed-patches lput clr-danger allowed-patches
   ]
    ;; new requirement in December - let the main building be a possible destination.
    if destination-building = 1 [
         set allowed-patches lput clr-fixed-facility allowed-patches
    ]
end

;;
;; set-worker-avoider
;;
;; give a worker "avoider" properties, going around mud or danger
;;
to set-worker-avoider [colorB]
  set allowed-patches (list clr-path clr-road clr-moveable-facility  red )
  set color colorB
  ;; new requirement in December - let the main building be a possible destination.
  if destination-building = 1 [
       set allowed-patches lput clr-fixed-facility allowed-patches
  ]
end



;;
;; set-new-destination
;;
;; called when:  create people, arrive at destination, buildings move
;;
to set-new-destination [new-dest new-searching add-trip ]
      let thegoal one-of patches with [building-number = new-dest]
      ask patch pxcor pycor [
         set thegoal shoot-a-dart new-dest
      ]
      set goal thegoal
      face goal
      set searching?  new-searching
      set trips-completed trips-completed + add-trip
      set previous-patch patch 0 0
      set dice-tossed? 0
      set hugging-edges-steps 0
      set blue-sky-steps 0

      ;; tell turtle which direction it will need to turn to go away from the center
      let centerheading towardsxy 105 105
      ifelse (subtract-headings centerheading heading > 0) [
        set go-right? false
      ] [
        set go-right? true
      ]
      
      ;; choose a trail of breadcrumbs
      let bold 1
      if avoid-mud? = true or avoid-mud? = 1 [ set bold 0 ]
      let src home-building
      if new-dest = home-building [set src destination-building]
      let crumbly select-breadcrumbs src new-dest bold

      if length breadcrumb-trails > 6 [
         if length crumbly > 2 [
           let mytrail item (item 0 crumbly) breadcrumb-trails
         ]
      ]
      
      if length crumbly > 2 [
        set trail-id item 0 crumbly     
        set breadcrumb-reverse item 1 crumbly     ;; true/false
        set breadcrumb-num item 2 crumbly    
      ]
end


