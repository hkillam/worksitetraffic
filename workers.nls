;;
;; WORKERS
;;
;; describe workers and store information
;; functions to create and direct them
;;

breed [ workers ]

globals [
  group-history   ;; an array for each group:  source, dest, bold, num-in-group, list of trip counts at each tick
  
  ;; indexes in the group-history array
  I-grpsrc
  I-grpdst
  I-grpbold
  I-grpcount
]


workers-own [
  searching?            ;; 1 if going to the materials, 0 if returning\
  is-bold?              ;; true, will go through obsticles
  energy                ;; start at tick-count, at zero just quit
  allowed-patches       ;; colours of patches this guy can step on
  trips-completed       ;; number of round-trip journies
  home-building         ;; place this worker starts out
  destination-building  ;; number of the building they are currently heading to
  goal                  ;; random space within the building they are heading to
  dice-tossed?          ;; for people in the danger zone, toss the dice once per trip
  no-energy-tick        ;; the tick count when this worker runs out of energy
  go-right?             ;; true if this turtle looks to the right for an open route.  set this when the goal is set
  hugging-edges-steps   ;; if the turtle starts hugging the edge, this is how many more steps to do it for
  working-ticks         ;; count down how long a worker stays in a work building
  trail-id              ;; which string of breadcrumbs is he following
  breadcrumb-reverse    ;; true if starting at end and going to beginning
  breadcrumb-num        ;; how far along the string of breadcrumbs is he
  injured?              ;; has this worker been injured?
  bump-count            ;; how often does this worker step aside because of the crowd ahead
  jammed-count          ;; how often does this worker not move at all because of the crowd ahead
  time-in-obstacle      ;; how much time is spent wading in the mud
  steps-from-path       ;; how many times did this worker step aside for someone else, and to which side?  -1 left, 1 right
  planned-injury        ;; If this is non-zero, the worker will be injured at this step.  This allows us to control the percentage injury by group instead of by trip or by step.
]


;;
;; setup-workers
;;
;; called from setup function to read building list and generate all of the workers
;;
to setup-workers
  set I-grpsrc   0
  set I-grpdst   1
  set I-grpbold  2   ;; true/false
  set I-grpcount 3
  set group-history []
  


  foreach building-list [
    let buildnum  item I-ID ?
    if buildnum != "facility" [
      let buildname  item I-Name ?
      let numworkers  item I-NumWorkers ? 
      let dest item I-Dest ?

      create-workers numworkers [
        move-to one-of patches with [building-number = buildnum]
        let color1 75
        let color2 65
        if (buildnum = 14) [ set color1 orange set color2 yellow ]
        if (buildnum = 18) [ set color1 95 set color2 85 ]
        if (buildnum = 15) [ set color1 115 set color2 125  ]
        init-worker color1 color2 dest buildnum
      ]
      
      ;; for workers going through the danger zone, xx% of them will be injured.  This is a change from calculating it per trip or per step.
      let hazard-pay item I-Harm ?
      ask workers with [home-building = buildnum and is-bold? = true and hazard-pay > 0] [
        ;; injury rate is found in buildings.csv, and made into a global variable
        let odds random 100
        if odds < 2 [ set planned-injury random total-ticks]
      ]
      
      ;; create the list of group records
      if is-list? dest [
        foreach dest
        [
          let bold-workers count workers with [home-building = buildnum and destination-building = ? and is-bold? = true]
          let avoiders count workers with [home-building = buildnum and destination-building = ? and is-bold? = false]
          ;;show (word "bold: " bold-workers " chicken: " avoiders)
          set group-history lput  (list buildnum ? true bold-workers) group-history
          set group-history lput  (list buildnum ? false avoiders) group-history
        ]
      ]
    ]
  ]

end

to fresh-workers
  ask workers [die]  ;; make sure there aren't leftovers.
  reset-ticks
  setup-workers
end


;;
;; record-group-stats
;;
;; For every tick, grab the current stats on each group (trips completed, tired workers)
;;
to record-group-stats
  let new-history []
  foreach group-history
  [
    let thegroup workers with [is-bold? = item I-grpbold ? and home-building = item I-grpsrc ? and destination-building = item I-grpdst ? ]
    if count thegroup > 0 [
       let sum-trips  sum [trips-completed] of  thegroup
       let avg-trips  mean [trips-completed] of  thegroup
       let retired count  thegroup with [energy <= 0 and injured? = false ]
       let injured count  thegroup with [injured? = true ]
       set new-history lput (lput (list ticks sum-trips  avg-trips retired injured) ?) new-history
    ]
  ]
  set group-history new-history
end

;;
;; write-worker-stats
;;
;; Create a file for each group, show all of the stats for every tick.
;;
to write-worker-stats
  ;; start with column headers
  let myheaders ["ticks" "total trips" "average trips" "retired" "injured"]
  


  foreach group-history
  [
     let myout (list myheaders)
     
     foreach ? [
       if is-list? ? [ set myout lput ? myout ]
     ]

     ;; create a filename, and write the results
     let filename (word "C:\\WorksiteTrafficResults\\results-group" item I-grpsrc ? "to" item I-grpdst ?)
     ifelse item I-grpbold ? = true
     [ set filename (word filename "bold.csv") ]
     [ set filename (word filename "avoider.csv") ]
     csv:to-file filename myout
  ]
  
  show "Results have been saved to C:\\WorksiteTrafficResults\\results-group"
end


;;
;; write-worker-summaries
;;
;; Creates a file listing summaries for each group.  A group is workers who share the same source and dest.
;;
to write-worker-summaries
  ;; building stats
  let myheaders ["source building" "dest building" "number of avoiders" "number of bold workers" "average trips for avoiders" "average trips for bold" "average time per trip avoiders" "average time per trip bold" "average ticks mudders get tired" "num injured workers"]
  let myout (list myheaders)

  foreach building-list [
    let buildnum  item I-ID ?
    foreach item I-Dest ?
    [
      let mystats group-stats  buildnum ?
      set myout lput mystats myout
    ]
  ]
  csv:to-file "C:\\WorksiteTrafficResults\\results-groupstats.csv" myout

end



;;
;; init-worker
;;
;; Initializes a single worker, personality, destination.
;; input: colours for bold/timid, list of possible destinations, home
;;
to init-worker [  colorA colorB dest-buildings home-plate]
      let dest one-of dest-buildings
      set home-building home-plate
      set destination-building dest
      set bump-count 0
      set jammed-count 0
      set time-in-obstacle 0
      set size 1
      set breed workers
      set injured? false
      set trips-completed 0
      set energy total-ticks
      set is-bold? one-of [true false]
      ifelse is-bold? = true
      [  
         set-worker-bold colorA
      ][
         set-worker-avoider colorB
      ]

      set no-energy-tick 0
      set breadcrumb-num 0
      set-new-destination dest 1 0
      set steps-from-path 0
      set planned-injury 0    ;; most people don't expect to be injured, but some will have a sword of Damacles over their heads.  They just don't know it  yet.
end

;;
;; set-worker-bold
;;
;; give a worker "bold" properties, charging through mud, laughing at danger, unstoppable (unless it's mother calls)
;;
to set-worker-bold [colorA]
  set color colorA
  set is-bold? true
   set allowed-patches (list clr-path clr-road clr-moveable-facility )
   set allowed-patches lput clr-slowmud allowed-patches
   set allowed-patches lput clr-tiredmud allowed-patches
   set allowed-patches lput clr-danger allowed-patches
   
    ;; new requirement in December - let the main building be a possible destination.
    if destination-building = 1 [
         set allowed-patches lput clr-fixed-facility allowed-patches
    ]
end

;;
;; set-worker-avoider
;;
;; give a worker "avoider" properties, going around mud or danger
;;
to set-worker-avoider [colorB]
  set is-bold? false
  set allowed-patches (list clr-path clr-road clr-moveable-facility )
  set color colorB
  ;; new requirement in December - let the main building be a possible destination.
  if destination-building = 1 [
       set allowed-patches lput clr-fixed-facility allowed-patches
  ]
end



;;
;; set-new-destination
;;
;; workers - follow the breadcrumbs
;; called when:  create people, arrive at destination, buildings move
;;
to set-new-destination [new-dest new-searching add-trip ]
      let thegoal one-of patches with [building-number = new-dest]
      ask patch pxcor pycor [
         set thegoal shoot-a-dart new-dest
      ]
      set goal thegoal
      face goal
      set searching?  new-searching
      set trips-completed trips-completed + add-trip
      set dice-tossed? 0
      set hugging-edges-steps 0
      set steps-from-path 0

      ;; tell turtle which direction it will need to turn to go away from the center
      ;; this is leftover from code where the turtles each found their own way, and would tell them which way to look for a path.
      let centerheading towardsxy 105 105
      ifelse (subtract-headings centerheading heading > 0) [
        set go-right? false
      ] [
        set go-right? true
      ]
      
      ;; change shade of worker
      ifelse new-dest = home-building [set color color + 1][set color color - 1]
      
      ;; choose a trail of breadcrumbs
      let src home-building
      if new-dest = home-building [set src destination-building]
      let crumbly select-breadcrumbs src new-dest is-bold?

      if length breadcrumb-trails > 6 [
         if length crumbly > 2 [
           let mytrail item (item 0 crumbly) breadcrumb-trails
         ]
      ]
      
      if length crumbly > 2 [
        set trail-id item 0 crumbly     
        set breadcrumb-reverse item 1 crumbly     ;; true/false
        set breadcrumb-num item 2 crumbly    
      ]
end


;;
;; redirect-workers
;;
;; called when:  a building moves after "go" is pressed.
;;
to redirect-workers
         ;; some workers were heading to this building, redirect them to the new destination
         ask workers with [destination-building = building-to-move and searching? = true][
           set-new-destination destination-building searching? 0
         ]
         ask workers with [home-building = building-to-move and searching? = false][
           set-new-destination home-building searching? 0
         ]
end




;;
;; check-goal
;;
;; worker procedure - if they have reached the goal, set a new one
;;
to check-goal

  ;; did we reach the destination?  return to home!
  if building-number = destination-building and searching? = 1 [
    set-new-destination  home-building 0 0
    set working-ticks  (work-time destination-building)
  ]

  ;; did we reach the home?  go to destination
  if building-number = home-building and searching? = 0 [
    set-new-destination  destination-building 1 1
  ]
end




;;
;; check-goal
;;
;; worker procedure, single worker
;; spend time working, see if obsticle impacts the next step, bump into each other
;;
to move-worker

    ;; if they are done for the day, stop
    if color = black [
      stop;
    ]

    ;; let the worker spend some time working int the dest building.
    if working-ticks > 0 [
      set working-ticks working-ticks - 1
      set energy energy - 1
      stop
    ]

     let step-size 1
     let effort 1
     let chance-of-injury-percent 0


    without-interruption
     [

         ;;set-direction little-dude
         follow-the-yellow-brick-road

         let nextpcolor [pcolor] of patch-ahead 1

         if not member? nextpcolor  allowed-patches [
           set hugging-edges-steps 10
         ]

         ;; check for sticky situations
         if pcolor = clr-slowmud and is-bold? = true
         [ set step-size obslow-speed 
           set effort obslow-energy
           set chance-of-injury-percent obslow-injury
         ]
         if pcolor = clr-tiredmud and is-bold? = true
         [ 
           set step-size obtired-speed 
           set effort obtired-energy
           set chance-of-injury-percent obtired-injury
         ]
         if pcolor = clr-danger and is-bold? = true
         [
           set step-size obdanger-speed 
           set effort obdanger-energy
           set chance-of-injury-percent obdanger-injury
         ]


         ;; roll the dice if we are in a danger zone  (old method - test for injury once per trip through the danger zone)
         ;;if chance-of-injury-percent > 0 and dice-tossed? = 0 [
         ;;    if random 100 < chance-of-injury-percent
         ;;    [ 
         ;;         set color black
         ;;         set injured? true
         ;;         set energy 0
         ;;         move-to patch 1 1
         ;;     ]
         ;;     set dice-tossed? 1
         ;;]
         
         if planned-injury > 0 and ticks = planned-injury [
           ;;; bwahahahahah <evil laughter>  you did not know that your doom was set before you started.  And now you have reached the end of your time.
           set injured? true
           set color black
           set energy 0
           move-to patch 1 1
         ]



         ;; check for someone on that patch, step to the right (unless we are already hugging an edge)
         if (count (turtles-on (patch-ahead 1)) >= (max-turtles-per-square + 1)  ;; add one becasue the current worker sees himself, we are checking for other workers.
            and [building-number] of patch-ahead 1 = 0)
         [
           
           ;; see if this guy is a buddy going the same direction as you
           let buddies false
           let my-group-id (list searching? home-building destination-building)
           ask turtles-on (patch-ahead 1) [
             if searching? = (item 0 my-group-id)
             and home-building = item 1 my-group-id
             and destination-building = item 2 my-group-id
             [
               set buddies true;
             ]
           ]
           
           
           ;; check how far we have stepped from path and try to go back (if there is a trail)
           let nextpatch patch-right-and-ahead 90 step-size
           ifelse (steps-from-path < -1 or steps-from-path > 1) and breadcrumb-num >= I-firstpoint
           [
             ifelse steps-from-path > 0
             [ set nextpatch patch-left-and-ahead 90 step-size
               set steps-from-path steps-from-path - 1]
             [ set steps-from-path steps-from-path + 1]
           ]
           [
             ;; if the workers ahead are your buddies, go left, otherwise go right.  Left will help avoid clumping around a stuck guy.
             ifelse buddies = true
             [ set nextpatch patch-left-and-ahead 90 step-size
               set steps-from-path steps-from-path - 1]
             [ set steps-from-path steps-from-path + 1]
           ]
           
            
           set nextpcolor [pcolor] of nextpatch
            ifelse ( member? nextpcolor  allowed-patches 
              and ((count (turtles-on (nextpatch)) < max-turtles-per-square) or [building-number] of nextpatch = 0))
            [
              
              ;; TODO - check to see if the person ahead is the same group going the same direction.  Step left instead, because one stopped person can jam everyone that steps in behind.
               move-to nextpatch
               set bump-count bump-count + 1
               ;;show "bump"
               set energy energy - effort
               stop
            ][
               set jammed-count jammed-count + 1
            ]
            stop
         ]


         ;; and move!
         set energy energy - effort
         forward step-size

         ;; record muddy steps
         if  member? pcolor (list clr-slowmud clr-tiredmud clr-danger)
         [  set time-in-obstacle time-in-obstacle + 1]

         ;; tired yet?
         if energy < 1 and no-energy-tick = 0 [
           set color black
           set no-energy-tick  ticks
           pen-up
           move-to patch 1 1
         ]

    ]
end



