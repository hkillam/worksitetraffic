;;
;; WORKERS
;;
;; describe workers and store information
;; functions to create and direct them
;;

breed [ workers ]

globals [
  group-history   ;; an array for each group:  source, dest, bold, num-in-group, list of trip counts at each tick
  
  ;; indexes in the group-history array
  I-grpsrc
  I-grpdst
  I-grpbold
  I-grpcount
]


workers-own [
  searching?            ;; 1 if going to the materials, 0 if returning\
  is-bold?              ;; true, will go through obsticles
  energy                ;; start at tick-count, at zero just quit
  allowed-patches       ;; colours of patches this guy can step on
  trips-completed       ;; number of round-trip journies
  home-building         ;; place this worker starts out
  destination-building  ;; number of the building they are currently heading to
  goal                  ;; random space within the building they are heading to
  dice-tossed?          ;; for people in the danger zone, toss the dice once per trip
  no-energy-tick        ;; the tick count when this worker runs out of energy
  go-right?             ;; true if this turtle looks to the right for an open route.  set this when the goal is set
  hugging-edges-steps   ;; if the turtle starts hugging the edge, this is how many more steps to do it for
  working-ticks         ;; count down how long a worker stays in a work building
  trail-id              ;; which string of breadcrumbs is he following
  breadcrumb-reverse    ;; true if starting at end and going to beginning
  breadcrumb-num        ;; how far along the string of breadcrumbs is he
  injured?              ;; has this worker been injured?
  bump-count            ;; how often does this worker step aside because of the crowd ahead
  jammed-count          ;; how often does this worker not move at all because of the crowd ahead
  time-in-obstacle      ;; how much time is spent wading in the mud
]


;;
;; setup-workers
;;
;; called from setup function to read building list and generate all of the workers
;;
to setup-workers
  set I-grpsrc   0
  set I-grpdst   1
  set I-grpbold  2   ;; true/false
  set I-grpcount 3
  set group-history []

  foreach building-list [
    let buildnum  item I-ID ?
    if buildnum != "facility" [
      let buildname  item I-Name ?
      let numworkers  item I-NumWorkers ? 
      let dest item I-Dest ?

      create-workers numworkers [
        move-to one-of patches with [building-number = buildnum]
        let color1 75
        let color2 65
        if (buildnum = 14) [ set color1 orange set color2 yellow ]
        if (buildnum = 18) [ set color1 95 set color2 85 ]
        if (buildnum = 15) [ set color1 115 set color2 125  ]
        init-worker color1 color2 dest buildnum
      ]
      
      ;; create the list of group records
      if is-list? dest [
        foreach dest
        [
          let bold-workers count workers with [home-building = buildnum and destination-building = ? and is-bold? = true]
          let avoiders count workers with [home-building = buildnum and destination-building = ? and is-bold? = false]
          ;;show (word "bold: " bold-workers " chicken: " avoiders)
          set group-history lput  (list buildnum ? true bold-workers) group-history
          set group-history lput  (list buildnum ? false avoiders) group-history
        ]
      ]
    ]
  ]

end


;;
;; record-group-stats
;;
;; For every tick, grab the current stats on each group (trips completed, tired workers)
;;
to record-group-stats
  let new-history []
  foreach group-history
  [
    let thegroup workers with [is-bold? = item I-grpbold ? and home-building = item I-grpsrc ? and destination-building = item I-grpdst ? ]
    if count thegroup > 0 [
       let sum-trips  sum [trips-completed] of  thegroup
       let avg-trips  mean [trips-completed] of  thegroup
       let retired count  thegroup with [energy <= 0 and injured? = false ]
       let injured count  thegroup with [injured? = true ]
       set new-history lput (lput (list ticks sum-trips  avg-trips retired injured) ?) new-history
    ]
  ]
  set group-history new-history
end

;;
;; write-worker-stats
;;
;; Create a file for each group, show all of the stats for every tick.
;;
to write-worker-stats
  ;; start with column headers
  let myheaders ["ticks" "total trips" "average trips" "retired" "injured"]
  


  foreach group-history
  [
     let myout (list myheaders)
     
     foreach ? [
       if is-list? ? [ set myout lput ? myout ]
     ]

     ;; create a filename, and write the results
     let filename (word "C:\\WorksiteTrafficResults\\results-group" item I-grpsrc ? "to" item I-grpdst ?)
     ifelse item I-grpbold ? = true
     [ set filename (word filename "bold.csv") ]
     [ set filename (word filename "avoider.csv") ]
     csv:to-file filename myout
  ]
end


;;
;; write-worker-summaries
;;
;; Creates a file listing summaries for each group.  A group is workers who share the same source and dest.
;;
to write-worker-summaries
  ;; building stats
  let myheaders ["source building" "dest building" "number of avoiders" "number of bold workers" "average trips for avoiders" "average trips for bold" "average time per trip avoiders" "average time per trip bold" "average ticks mudders get tired" "num injured workers"]
  let myout (list myheaders)

  foreach building-list [
    let buildnum  item I-ID ?
    foreach item I-Dest ?
    [
      let mystats group-stats  buildnum ?
      set myout lput mystats myout
    ]
  ]
  csv:to-file "C:\\WorksiteTrafficResults\\results-groupstats.csv" myout

end



;;
;; init-worker
;;
;; Initializes a single worker, personality, destination.
;; input: colours for bold/timid, list of possible destinations, home
;;
to init-worker [  colorA colorB dest-buildings home-plate]
      let dest one-of dest-buildings
      set home-building home-plate
      set destination-building dest
      set bump-count 0
      set jammed-count 0
      set time-in-obstacle 0
      set size 1
      set breed workers
      set injured? false
      set trips-completed 0
      set energy total-ticks
      set is-bold? one-of [true false]
      ifelse is-bold? = true
      [  
         set-worker-bold colorA
      ][
         set-worker-avoider colorB
      ]

      set no-energy-tick 0
      set-new-destination dest 1 0
end

;;
;; set-worker-bold
;;
;; give a worker "bold" properties, charging through mud, laughing at danger, unstoppable (unless it's mother calls)
;;
to set-worker-bold [colorA]
  set color colorA
  set is-bold? true
   set allowed-patches (list clr-path clr-road clr-moveable-facility )
   set allowed-patches lput clr-slowmud allowed-patches
   set allowed-patches lput clr-tiredmud allowed-patches
   set allowed-patches lput clr-danger allowed-patches
   
    ;; new requirement in December - let the main building be a possible destination.
    if destination-building = 1 [
         set allowed-patches lput clr-fixed-facility allowed-patches
    ]
end

;;
;; set-worker-avoider
;;
;; give a worker "avoider" properties, going around mud or danger
;;
to set-worker-avoider [colorB]
  set is-bold? false
  set allowed-patches (list clr-path clr-road clr-moveable-facility )
  set color colorB
  ;; new requirement in December - let the main building be a possible destination.
  if destination-building = 1 [
       set allowed-patches lput clr-fixed-facility allowed-patches
  ]
end



;;
;; set-new-destination
;;
;; workers - follow the breadcrumbs
;; called when:  create people, arrive at destination, buildings move
;;
to set-new-destination [new-dest new-searching add-trip ]
      let thegoal one-of patches with [building-number = new-dest]
      ask patch pxcor pycor [
         set thegoal shoot-a-dart new-dest
      ]
      set goal thegoal
      face goal
      set searching?  new-searching
      set trips-completed trips-completed + add-trip
      set dice-tossed? 0
      set hugging-edges-steps 0

      ;; tell turtle which direction it will need to turn to go away from the center
      let centerheading towardsxy 105 105
      ifelse (subtract-headings centerheading heading > 0) [
        set go-right? false
      ] [
        set go-right? true
      ]
      
      ;; choose a trail of breadcrumbs
      let src home-building
      if new-dest = home-building [set src destination-building]
      let crumbly select-breadcrumbs src new-dest is-bold?

      if length breadcrumb-trails > 6 [
         if length crumbly > 2 [
           let mytrail item (item 0 crumbly) breadcrumb-trails
         ]
      ]
      
      if length crumbly > 2 [
        set trail-id item 0 crumbly     
        set breadcrumb-reverse item 1 crumbly     ;; true/false
        set breadcrumb-num item 2 crumbly    
      ]
end


;;
;; redirect-workers
;;
;; called when:  a building moves after "go" is pressed.
;;
to redirect-workers
         ;; some workers were heading to this building, redirect them to the new destination
         ask workers with [destination-building = building-to-move and searching? = true][
           set-new-destination destination-building searching? 0
         ]
         ask workers with [home-building = building-to-move and searching? = false][
           set-new-destination home-building searching? 0
         ]
end




;;
;; check-goal
;;
;; worker procedure - if they have reached the goal, set a new one
;;
to check-goal

  ;; did we reach the destination?  return to home!
  if building-number = destination-building and searching? = 1 [
    set-new-destination  home-building 0 0
    set working-ticks  (work-time destination-building)
  ]

  ;; did we reach the home?  go to destination
  if building-number = home-building and searching? = 0 [
    set-new-destination  destination-building 1 1
  ]
end




;;
;; check-goal
;;
;; worker procedure, single worker
;; spend time working, see if obsticle impacts the next step, bump into each other
;;
to move-worker

    ;; if they are done for the day, stop
    if color = black [
      stop;
    ]

    ;; let the worker spend some time working int the dest building.
    if working-ticks > 0 [
      set working-ticks working-ticks - 1
      set energy energy - 1
      stop
    ]

     let step-size 1
     let effort 1
     let chance-of-injury-percent 0


    without-interruption
     [

         ;;set-direction little-dude
         follow-the-yellow-brick-road

         let nextpatch [pcolor] of patch-ahead 1

         if not member? nextpatch  allowed-patches [
           set hugging-edges-steps 10
         ]

         ;; check for sticky situations
         if pcolor = clr-slowmud 
         [ set step-size obslow-speed 
           set effort obslow-energy
           set chance-of-injury-percent obslow-injury
         ]
         if pcolor = clr-tiredmud 
         [ 
           set step-size obtired-speed 
           set effort obtired-energy
           set chance-of-injury-percent obtired-injury
         ]
         if pcolor = clr-danger
         [
           set step-size obdanger-speed 
           set effort obdanger-energy
           set chance-of-injury-percent obdanger-injury
         ]


         ;; roll the dice if we are in a danger zone
         if chance-of-injury-percent > 0 and dice-tossed? = 0 [
             if random 100 < chance-of-injury-percent
             [ 
                  set color black
                  set injured? true
                  set energy 0
                  move-to patch 1 1
              ]
              set dice-tossed? 1
         ]



         ;; check for someone on that patch, step to the right (unless we are already hugging an edge)
         if (count (turtles-on (patch-ahead 1)) >= max-turtles-per-square
            and [building-number] of patch-ahead 1 = 0)
         [
            set nextpatch [pcolor] of patch-right-and-ahead 90 1
            ifelse ( member? nextpatch  allowed-patches and count (turtles-on (patch-right-and-ahead 90 1)) < max-turtles-per-square)
            [
               move-to patch-right-and-ahead 90 step-size
               set bump-count bump-count + 1
               ;;show "bump"
               set energy energy - effort
               stop
            ][
               set jammed-count jammed-count + 1
            ]
            stop
         ]


         ;; and move!
         set energy energy - effort
         forward step-size

         ;; record muddy steps
         if  member? pcolor (list clr-slowmud clr-tiredmud clr-danger)
         [  set time-in-obstacle time-in-obstacle + 1]

         ;; tired yet?
         if energy < 1 and no-energy-tick = 0 [
           set color black
           set no-energy-tick  ticks
           pen-up
           move-to patch 1 1
         ]

    ]
end



